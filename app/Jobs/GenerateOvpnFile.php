<?php

namespace App\Jobs;

use App\Models\VpnUser;
use Illuminate\Bus\Queueable;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Queue\SerializesModels;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;

class GenerateOvpnFile implements ShouldQueue
{
    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;

    protected VpnUser $vpnUser;
    protected $server = null;

    /**
     * Create a new job instance.
     *
     * @param VpnUser $vpnUser
     * @param object|null $server
     */
    public function __construct(VpnUser $vpnUser, $server = null)
    {
        $this->vpnUser = $vpnUser->load('vpnServers');
        $this->server = $server;
    }

    /**
     * Execute the job.
     */
    public function handle(): void
    {
        Log::info("üîß Generating OVPN file(s) for user: {$this->vpnUser->username}");

        // If a specific server is provided, generate only for that server
        if ($this->server) {
            $this->generateForServer($this->server);
            return;
        }

        // Otherwise, generate for all servers associated with the user
        if ($this->vpnUser->vpnServers->isEmpty()) {
            Log::warning("‚ö†Ô∏è No VPN servers associated with user {$this->vpnUser->username}");
            return;
        }

        foreach ($this->vpnUser->vpnServers as $server) {
            $this->generateForServer($server);
        }

        Log::info("‚úÖ Completed OVPN file generation for user: {$this->vpnUser->username}");
    }

    /**
     * Generate OVPN file for a specific server.
     *
     * @param object $server
     * @return void
     */
    protected function generateForServer($server): void
    {
        Log::info("üîß Generating OVPN file for server: {$server->name} ({$server->ip_address})");

        // Fetch server certificate files
        $files = [
            'ca' => '/etc/openvpn/ca.crt',
            'ta' => '/etc/openvpn/ta.key',
        ];

        $fetched = [];
        foreach ($files as $label => $path) {
            $content = $this->fetchRemoteFile($server->ip_address, $path, strtoupper($label));
            if (!$content) {
                Log::error("‚ùå [OVPN] Missing $label for server {$server->name}, skipping.");
                return;
            }
            $fetched[$label] = $content;
        }

        // Build OVPN config
        $username = $this->vpnUser->username;
        $ip = $server->ip_address;

        $config = <<<EOL
# Auto-generated by AIOVPN
client
dev tun
proto udp
remote $ip 1194
nobind
persist-key
persist-tun
remote-cert-tls server
auth SHA256
cipher AES-256-GCM
ncp-ciphers AES-256-GCM:AES-128-GCM
auth-user-pass
verb 3

<ca>
{$fetched['ca']}
</ca>

<tls-auth>
{$fetched['ta']}
</tls-auth>
key-direction 1
EOL;

        // Save config
        $fileName = "public/ovpn_configs/{$server->name}_$username.ovpn";
        Storage::put($fileName, $config);
        Storage::setVisibility($fileName, 'public');

        Log::info("‚úÖ [OVPN] Config saved: storage/app/$fileName");
    }

    /**
     * Fetch a file from a remote server via SSH.
     *
     * @param string $ip
     * @param string $remotePath
     * @param string $label
     * @return string|null
     */
    private function fetchRemoteFile(string $ip, string $remotePath, string $label): ?string
    {
        $sshKey = storage_path('app/ssh_keys/id_rsa');
        $sshUser = 'root';
        $command = "ssh -i $sshKey -o StrictHostKeyChecking=no -o ConnectTimeout=30 $sshUser@$ip 'cat $remotePath'";

        exec($command, $output, $status);
        if ($status !== 0 || empty($output)) {
            Log::error("‚ùå Failed to fetch $label from $ip.");
            return null;
        }

        return implode("\n", $output);
    }
}
