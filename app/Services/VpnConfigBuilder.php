<?php

namespace App\Services;

use App\Models\VpnUser;
use App\Models\VpnServer;
use App\Traits\ExecutesRemoteCommands;
use Carbon\Carbon;
use Exception;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class VpnConfigBuilder
{
    use ExecutesRemoteCommands;

    private const DEFAULT_OVPN_PORT = 1194;

    /**
     * Normalize/resolve a server IP regardless of field name.
     */
    private static function serverIp($server): ?string
    {
        // Supports Eloquent model, stdClass, or array-like
        $ip = $server->ip_address
            ?? ($server->ip ?? null)
            ?? (is_array($server) ? ($server['ip_address'] ?? ($server['ip'] ?? null)) : null);

        $ip = is_string($ip) ? trim($ip) : null;
        return $ip !== '' ? $ip : null;
    }

    /**
     * Return config descriptors for a user's assigned servers (no files written).
     */
    public static function generate(VpnUser $vpnUser): array
    {
        $items = [];
        foreach ($vpnUser->vpnServers as $server) {
            $safe = str_replace([' ', '(', ')'], ['_', '', ''], $server->name);
            $items[] = [
                'server_id'   => $server->id,
                'server_name' => $server->name,
                'filename'    => "{$safe}_{$vpnUser->username}.ovpn",
                'user_id'     => $vpnUser->id,
                'username'    => $vpnUser->username,
            ];
            Log::info("✅ Prepared on-demand OVPN config", [
                'user' => $vpnUser->username,
                'server_id' => $server->id,
                'server' => $server->name,
            ]);
        }
        return $items;
    }

    /**
     * Generate a WireGuard config as a string (no disk IO needed by caller).
     */
    public static function generateWireGuard(VpnUser $vpnUser): string
    {
        $server = $vpnUser->vpnServers->first();
        if (!$server) {
            Log::warning("⚠️ No server assigned for WireGuard", ['user' => $vpnUser->username]);
            return '';
        }

        $pubPath = "wireguard/{$server->id}/server_public_key";
        if (!Storage::disk('local')->exists($pubPath)) {
            Log::error("❌ Missing WireGuard server public key", ['path' => "storage/app/{$pubPath}"]);
            return '';
        }

        $serverPublicKey = trim(Storage::disk('local')->get($pubPath));
        $ip = self::serverIp($server);
        $endpoint = $ip ? "{$ip}:51820" : '0.0.0.0:51820';

        return <<<CONF
[Interface]
PrivateKey = {$vpnUser->wireguard_private_key}
Address = {$vpnUser->wireguard_address}
DNS = 1.1.1.1

[Peer]
PublicKey = {$serverPublicKey}
Endpoint = {$endpoint}
AllowedIPs = 0.0.0.0/0, ::/0
PersistentKeepalive = 25
CONF;
    }

    /**
     * Build an OpenVPN client config as a string (no disk).
     * Ensures CA/TLS are present; falls back to SSH fetch if not in storage.
     * @throws Exception
     */
    public static function generateOpenVpnConfigString(VpnUser $vpnUser, VpnServer $server): string
    {
        $ip = self::serverIp($server);
        if (!$ip) {
            $msg = "Server IP missing; cannot build OVPN";
            Log::error("❌ {$msg}", ['server_id' => $server->id, 'server' => $server->name]);
            throw new Exception($msg);
        }

        try {
            [$caCert, $tlsKey] = self::resolveCertificates($server);

            $remote = "{$ip} " . self::DEFAULT_OVPN_PORT;

            $cfg = <<<OVPN
# Auto-generated by AIOVPN
client
dev tun
proto udp
remote {$remote}
nobind
persist-key
persist-tun
remote-cert-tls server
auth SHA256
cipher AES-256-GCM
ncp-ciphers AES-256-GCM:AES-128-GCM
auth-user-pass
verb 3

<ca>
{$caCert}
</ca>

<tls-auth>
{$tlsKey}
</tls-auth>
key-direction 1

# Embedded user-pass
<auth-user-pass>
{$vpnUser->username}
{$vpnUser->password}
</auth-user-pass>
OVPN;

            Log::info("✅ OVPN config generated", [
                'user' => $vpnUser->username,
                'server_id' => $server->id,
                'server' => $server->name,
                'ip' => $ip,
            ]);
            return $cfg;

        } catch (Exception $e) {
            Log::error("❌ OVPN build failed", [
                'user' => $vpnUser->username,
                'server_id' => $server->id,
                'server' => $server->name,
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Resolve CA/TLS from storage or server; throw if missing.
     * @return array{0:string,1:string}
     * @throws Exception
     */
    private static function resolveCertificates(VpnServer $server): array
    {
        $ca = '';
        $ta = '';

        $caPath = "certs/{$server->id}/ca.crt";
        $taPath = "certs/{$server->id}/ta.key";

        if (Storage::disk('local')->exists($caPath)) {
            $ca = trim(Storage::disk('local')->get($caPath));
        }
        if (Storage::disk('local')->exists($taPath)) {
            $ta = trim(Storage::disk('local')->get($taPath));
        }

        if ($ca === '' || $ta === '') {
            $ip = self::serverIp($server);
            if (!$ip) {
                throw new Exception('Server IP missing; cannot fetch certificates.');
            }
            $inst = new static();
            $fetched = $inst->fetchCertificatesFromServer($server);
            $ca = $ca !== '' ? $ca : ($fetched['ca'] ?? '');
            $ta = $ta !== '' ? $ta : ($fetched['ta'] ?? '');
        }

        if ($ca === '' || $ta === '') {
            throw new Exception("Certificates unavailable for server {$server->id} ({$server->name}).");
        }

        return [$ca, $ta];
    }

    /**
     * Fetch certificates via SSH from the OpenVPN server.
     * @return array{ca:string,ta:string}
     */
    private function fetchCertificatesFromServer(VpnServer $server): array
    {
        $result = ['ca' => '', 'ta' => ''];
        $ip = self::serverIp($server);
        if (!$ip) {
            Log::error("❌ Fetch certs failed: missing IP", ['server_id' => $server->id, 'server' => $server->name]);
            return $result;
        }

        try {
            $ca = $this->executeRemoteCommand($ip, 'cat /etc/openvpn/ca.crt');
            if ($ca['status'] === 0 && !empty($ca['output'])) {
                $result['ca'] = implode("\n", $ca['output']);
            }

            $ta = $this->executeRemoteCommand($ip, 'cat /etc/openvpn/ta.key');
            if ($ta['status'] === 0 && !empty($ta['output'])) {
                $result['ta'] = implode("\n", $ta['output']);
            }

            Log::info("✅ Fetched certificates from server", [
                'server_id' => $server->id,
                'server' => $server->name,
                'ip' => $ip,
            ]);
        } catch (Exception $e) {
            Log::error("❌ Fetch certs exception", [
                'server_id' => $server->id,
                'server' => $server->name,
                'ip' => $ip,
                'error' => $e->getMessage(),
            ]);
        }

        return $result;
    }

    /**
     * Pull live OpenVPN sessions (supports both status formats).
     */
    public static function getLiveOpenVpnSessions(VpnServer $server): array
    {
        $ip = self::serverIp($server);
        if (!$ip) {
            Log::error("❌ Missing IP; cannot fetch sessions", ['server_id' => $server->id, 'server' => $server->name]);
            return [];
        }

        $inst = new static();

        try {
            // Prefer /var/log path (status-version 2), fallback to classic path
            $cmd = 'if [ -f /var/log/openvpn-status.log ]; then cat /var/log/openvpn-status.log; '
                 . 'elif [ -f /etc/openvpn/openvpn-status.log ]; then cat /etc/openvpn/openvpn-status.log; '
                 . 'else echo ""; fi';

            $res = $inst->executeRemoteCommand($ip, $cmd);
            if ($res['status'] !== 0) {
                Log::warning("⚠️ Could not read status", ['server' => $server->name, 'ip' => $ip]);
                return [];
            }

            $log = implode("\n", $res['output']);
            $sessions = self::parseStatusLog($log);

            Log::info("✅ Sessions fetched", [
                'server_id' => $server->id,
                'server' => $server->name,
                'count' => count($sessions),
            ]);

            return $sessions;

        } catch (Exception $e) {
            Log::error("❌ Live sessions error", [
                'server_id' => $server->id,
                'server' => $server->name,
                'ip' => $ip,
                'error' => $e->getMessage(),
            ]);
            return [];
        }
    }

    /**
     * Parse both status formats:
     *  - v1 (classic): "Common Name,Real Address,Bytes Received,Bytes Sent,Connected Since"
     *  - v2 (CSV):     HEADER,CLIENT_LIST,... and lines prefixed "CLIENT_LIST,..."
     */
    private static function parseStatusLog(string $statusLog): array
    {
        $sessions = [];
        if (trim($statusLog) === '') {
            return $sessions;
        }

        $lines = preg_split('/\r\n|\r|\n/', $statusLog);

        // v2 CSV first (safer if present)
        $sawCsv = false;
        foreach ($lines as $line) {
            $line = trim($line);
            if (str_starts_with($line, 'CLIENT_LIST,')) {
                $sawCsv = true;
                $p = explode(',', $line);
                // CLIENT_LIST, CN, RealAddr, VirtAddr, VirtIPv6, BytesRecv, BytesSent, ConnSince, ConnSince_ts, Username, ClientID, PeerID, Cipher
                if (count($p) >= 10) {
                    $commonName    = $p[1] ?? '';
                    $realAddress   = $p[2] ?? '';
                    $bytesReceived = (int)($p[5] ?? 0); // header shows Bytes Received first
                    $bytesSent     = (int)($p[6] ?? 0);
                    $ts            = (int)($p[8] ?? 0);
                    $username      = $p[9] ?? $commonName; // prefer Username, fallback to CN

                    $clientIp      = explode(':', $realAddress)[0];
                    $connectedAt   = $ts ? Carbon::createFromTimestamp($ts)->toDateTimeString() : null;

                    $sessions[] = [
                        'username'        => $username,
                        'real_address'    => $realAddress,
                        'client_ip'       => $clientIp,
                        'bytes_received'  => $bytesReceived,
                        'bytes_sent'      => $bytesSent,
                        'connected_since' => $connectedAt,
                        'total_bytes'     => $bytesReceived + $bytesSent,
                        'formatted_bytes' => self::formatBytes($bytesReceived + $bytesSent),
                    ];
                }
            }
        }
        if ($sawCsv) {
            return $sessions;
        }

        // v1 classic
        $inClients = false;
        foreach ($lines as $line) {
            $line = trim($line);

            if (str_contains($line, 'Common Name,Real Address,Bytes Received,Bytes Sent,Connected Since')) {
                $inClients = true;
                continue;
            }
            if ($inClients && str_starts_with($line, 'ROUTING TABLE')) {
                break;
            }
            if ($inClients && $line !== '' && str_contains($line, ',')) {
                $p = explode(',', $line);
                if (count($p) >= 5) {
                    $username       = trim($p[0]);
                    $realAddress    = trim($p[1]);
                    $bytesReceived  = (int) trim($p[2]);
                    $bytesSent      = (int) trim($p[3]);
                    $connectedSince = trim($p[4]);

                    $clientIp = explode(':', $realAddress)[0];

                    $connectedAt = null;
                    try {
                        $connectedAt = Carbon::createFromFormat('Y-m-d H:i:s', $connectedSince)->toDateTimeString();
                    } catch (\Throwable) {
                        $connectedAt = $connectedSince; // leave raw if parse fails
                    }

                    $sessions[] = [
                        'username'        => $username,
                        'real_address'    => $realAddress,
                        'client_ip'       => $clientIp,
                        'bytes_received'  => $bytesReceived,
                        'bytes_sent'      => $bytesSent,
                        'connected_since' => $connectedAt,
                        'total_bytes'     => $bytesReceived + $bytesSent,
                        'formatted_bytes' => self::formatBytes($bytesReceived + $bytesSent),
                    ];
                }
            }
        }

        return $sessions;
    }

    private static function formatBytes(int $bytes): string
    {
        if ($bytes >= 1073741824) return number_format($bytes / 1073741824, 2) . ' GB';
        if ($bytes >= 1048576)    return number_format($bytes / 1048576, 2) . ' MB';
        if ($bytes >= 1024)       return number_format($bytes / 1024, 2) . ' KB';
        return $bytes . ' B';
    }

    /**
     * SSH diagnostics to confirm service/port/certs.
     */
    public static function testOpenVpnConnectivity(VpnServer $server): array
    {
        $ip = self::serverIp($server);
        $out = [
            'server_reachable'       => false,
            'openvpn_running'        => false,
            'port_open'              => false,
            'certificates_available' => false,
            'details'                => [],
        ];

        if (!$ip) {
            $out['details']['error'] = 'Server IP missing';
            return $out;
        }

        $inst = new static();

        try {
            $ssh  = $inst->executeRemoteCommand($ip, 'echo ok');
            $out['server_reachable'] = ($ssh['status'] === 0);
            $out['details']['ssh'] = $ssh;

            if ($out['server_reachable']) {
                $svc  = $inst->executeRemoteCommand($ip, 'systemctl is-active openvpn@server');
                $port = $inst->executeRemoteCommand($ip, 'ss -ulnp | grep ":1194" || netstat -ulnp | grep ":1194"');
                $crt  = $inst->executeRemoteCommand($ip, 'test -s /etc/openvpn/ca.crt -a -s /etc/openvpn/ta.key && echo ok || echo missing');

                $out['openvpn_running']        = ($svc['status'] === 0 && in_array('active', $svc['output']));
                $out['port_open']              = ($port['status'] === 0 && !empty($port['output']));
                $out['certificates_available'] = ($crt['status'] === 0 && in_array('ok', $crt['output']));

                $out['details']['service'] = $svc;
                $out['details']['port']    = $port;
                $out['details']['certs']   = $crt;
            }

            Log::info("✅ Connectivity test complete", ['server_id' => $server->id, 'server' => $server->name, 'ip' => $ip]);
        } catch (Exception $e) {
            Log::error("❌ Connectivity test failed", ['server_id' => $server->id, 'server' => $server->name, 'ip' => $ip, 'error' => $e->getMessage()]);
            $out['details']['error'] = $e->getMessage();
        }

        return $out;
    }
}