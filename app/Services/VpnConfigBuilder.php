<?php

namespace App\Services;

use App\Models\VpnUser;
use App\Models\VpnServer;
use App\Traits\ExecutesRemoteCommands;
use Carbon\Carbon;
use Exception;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;

class VpnConfigBuilder
{
    use ExecutesRemoteCommands;

    /**
     * Return config descriptors for a user's assigned servers (no files written).
     */
    public static function generate(VpnUser $vpnUser): array
    {
        $items = [];
        foreach ($vpnUser->vpnServers as $server) {
            $safeName = str_replace([' ', '(', ')'], ['_', '', ''], $server->name);
            $items[] = [
                'server_id'   => $server->id,
                'server_name' => $server->name,
                'filename'    => "{$safeName}_{$vpnUser->username}.ovpn",
                'user_id'     => $vpnUser->id,
                'username'    => $vpnUser->username,
            ];
            Log::info("✅ Prepared on-demand OpenVPN config: {$safeName}_{$vpnUser->username}.ovpn");
        }
        return $items;
    }

    /**
     * Generate a WireGuard config (as a string, no disk).
     */
    public static function generateWireGuard(VpnUser $vpnUser): string
    {
        $server = $vpnUser->vpnServers->first();
        if (!$server) {
            Log::warning("⚠️ No server assigned to {$vpnUser->username} for WireGuard.");
            return '';
        }

        $pubPath = "wireguard/{$server->id}/server_public_key";
        if (!Storage::disk('local')->exists($pubPath)) {
            Log::error("❌ Missing WireGuard server public key at storage/app/{$pubPath}");
            return '';
        }

        $serverPublicKey = trim(Storage::disk('local')->get($pubPath));
        $endpoint = "{$server->ip_address}:51820";

        return <<<CONF
[Interface]
PrivateKey = {$vpnUser->wireguard_private_key}
Address = {$vpnUser->wireguard_address}
DNS = 1.1.1.1

[Peer]
PublicKey = {$serverPublicKey}
Endpoint = {$endpoint}
AllowedIPs = 0.0.0.0/0, ::/0
PersistentKeepalive = 25
CONF;
    }

    /**
     * Build an OpenVPN client config as a string (no disk).
     * Ensures CA/TLS are present; falls back to SSH fetch if not in storage.
     * @throws Exception
     */
    public static function generateOpenVpnConfigString(VpnUser $vpnUser, VpnServer $server): string
    {
        try {
            [$caCert, $tlsKey] = self::resolveCertificates($server);

            $remote = "{$server->ip_address} 1194";

            // AES-256-GCM (fast, modern); SHA256 for HMAC; explicit user/pass section embedded.
            $cfg = <<<OVPN
# Auto-generated by AIOVPN
client
dev tun
proto udp
remote {$remote}
nobind
persist-key
persist-tun
remote-cert-tls server
auth SHA256
cipher AES-256-GCM
ncp-ciphers AES-256-GCM:AES-128-GCM
auth-user-pass
verb 3

<ca>
{$caCert}
</ca>

<tls-auth>
{$tlsKey}
</tls-auth>
key-direction 1

# Embedded user-pass
<auth-user-pass>
{$vpnUser->username}
{$vpnUser->password}
</auth-user-pass>
OVPN;

            Log::info("✅ OpenVPN config generated for {$vpnUser->username} @ {$server->name}");
            return $cfg;

        } catch (Exception $e) {
            Log::error("❌ OVPN build failed for {$vpnUser->username} @ {$server->name}: {$e->getMessage()}");
            throw $e;
        }
    }

    /**
     * Resolve CA/TLS from storage or server; throw if missing.
     * @return array{0:string,1:string}
     */
    private static function resolveCertificates(VpnServer $server): array
    {
        $ca = '';
        $ta = '';

        $caPath = "certs/{$server->id}/ca.crt";
        $taPath = "certs/{$server->id}/ta.key";

        if (Storage::disk('local')->exists($caPath)) {
            $ca = trim(Storage::disk('local')->get($caPath));
        }
        if (Storage::disk('local')->exists($taPath)) {
            $ta = trim(Storage::disk('local')->get($taPath));
        }

        if (empty($ca) || empty($ta)) {
            $inst = new static();
            if (empty($server->ip_address)) {
                throw new Exception('Server IP missing; cannot fetch certificates.');
            }
            $fetched = $inst->fetchCertificatesFromServer($server);
            $ca = $ca ?: ($fetched['ca'] ?? '');
            $ta = $ta ?: ($fetched['ta'] ?? '');
        }

        if (empty($ca) || empty($ta)) {
            throw new Exception("Certificates unavailable for server {$server->id} ({$server->name}).");
        }

        return [$ca, $ta];
    }

    /**
     * Fetch certificates via SSH from the OpenVPN server.
     * @return array{ca:string,ta:string}
     */
    private function fetchCertificatesFromServer(VpnServer $server): array
    {
        $result = ['ca' => '', 'ta' => ''];

        try {
            $ca = $this->executeRemoteCommand($server->ip_address, 'cat /etc/openvpn/ca.crt');
            if ($ca['status'] === 0 && !empty($ca['output'])) {
                $result['ca'] = implode("\n", $ca['output']);
            }

            $ta = $this->executeRemoteCommand($server->ip_address, 'cat /etc/openvpn/ta.key');
            if ($ta['status'] === 0 && !empty($ta['output'])) {
                $result['ta'] = implode("\n", $ta['output']);
            }

            Log::info("✅ Fetched certificates from {$server->name}");
        } catch (Exception $e) {
            Log::error("❌ Fetch certs failed on {$server->name}: {$e->getMessage()}");
        }

        return $result;
    }

    /**
     * Pull live OpenVPN sessions (supports status v1 and status-version 2).
     */
    public static function getLiveOpenVpnSessions(VpnServer $server): array
    {
        $inst = new static();
        if (empty($server->ip_address)) {
            Log::error("❌ Missing IP for {$server->name}; cannot fetch status.");
            return [];
        }

        try {
            // Prefer status-version 2 path if present; fall back to classic path.
            $cmd = 'if [ -f /var/log/openvpn-status.log ]; then cat /var/log/openvpn-status.log; '
                 . 'elif [ -f /etc/openvpn/openvpn-status.log ]; then cat /etc/openvpn/openvpn-status.log; '
                 . 'else echo ""; fi';

            $res = $inst->executeRemoteCommand($server->ip_address, $cmd);
            if ($res['status'] !== 0) {
                Log::warning("⚠️ Could not read status on {$server->name}");
                return [];
            }

            $log = implode("\n", $res['output']);
            $sessions = self::parseStatusLog($log);

            Log::info("✅ {$server->name}: found " . count($sessions) . " active session(s).");
            return $sessions;

        } catch (Exception $e) {
            Log::error("❌ Live sessions error on {$server->name}: {$e->getMessage()}");
            return [];
        }
    }

    /**
     * Parse both status formats:
     *  - v1 (classic): "Common Name,Real Address,Bytes Received,Bytes Sent,Connected Since"
     *  - v2 (CSV):     lines starting with "CLIENT_LIST,..."
     */
    private static function parseStatusLog(string $statusLog): array
    {
        $sessions = [];
        if (trim($statusLog) === '') {
            return $sessions;
        }

        $lines = preg_split('/\r\n|\r|\n/', $statusLog);

        // Try v2 CSV first.
        $hasCsv = false;
        foreach ($lines as $line) {
            $line = trim($line);
            if (str_starts_with($line, 'CLIENT_LIST,')) {
                $hasCsv = true;
                $parts = explode(',', $line);
                // CLIENT_LIST,CommonName,RealAddr,VirtualAddr,VirtualIPv6,BytesIn,BytesOut,ConnectedSince,ConnectedSince_ts,Username,ClientID,PeerID,Cipher
                if (count($parts) >= 9) {
                    $username      = $parts[1];
                    $realAddress   = $parts[2];
                    $bytesReceived = (int)($parts[6] ?? 0);
                    $bytesSent     = (int)($parts[5] ?? 0); // note: v2 lists Bytes Sent then Bytes Received order differs sometimes; keep both
                    $connectedAtTs = (int)($parts[8] ?? 0);

                    $clientIp = explode(':', $realAddress)[0];
                    $connectedAt = $connectedAtTs ? Carbon::createFromTimestamp($connectedAtTs) : null;

                    $sessions[] = [
                        'username'         => $username,
                        'real_address'     => $realAddress,
                        'client_ip'        => $clientIp,
                        'bytes_received'   => $bytesReceived,
                        'bytes_sent'       => $bytesSent,
                        'connected_since'  => $connectedAt ? $connectedAt->toDateTimeString() : null,
                        'total_bytes'      => $bytesReceived + $bytesSent,
                        'formatted_bytes'  => self::formatBytes($bytesReceived + $bytesSent),
                    ];
                }
            }
        }
        if ($hasCsv) {
            return $sessions;
        }

        // Fallback: v1 classic table.
        $inClients = false;
        foreach ($lines as $line) {
            $line = trim($line);

            if (str_contains($line, 'Common Name,Real Address,Bytes Received,Bytes Sent,Connected Since')) {
                $inClients = true;
                continue;
            }
            if ($inClients && str_starts_with($line, 'ROUTING TABLE')) {
                break;
            }
            if ($inClients && $line !== '' && str_contains($line, ',')) {
                $p = explode(',', $line);
                if (count($p) >= 5) {
                    $username      = trim($p[0]);
                    $realAddress   = trim($p[1]);
                    $bytesReceived = (int) trim($p[2]);
                    $bytesSent     = (int) trim($p[3]);
                    $connectedSince= trim($p[4]);

                    $clientIp = explode(':', $realAddress)[0];
                    $connectedAt = null;
                    try {
                        $connectedAt = Carbon::createFromFormat('Y-m-d H:i:s', $connectedSince);
                    } catch (\Throwable) {
                        // ignore parse fail
                    }

                    $sessions[] = [
                        'username'         => $username,
                        'real_address'     => $realAddress,
                        'client_ip'        => $clientIp,
                        'bytes_received'   => $bytesReceived,
                        'bytes_sent'       => $bytesSent,
                        'connected_since'  => $connectedAt?->toDateTimeString() ?? $connectedSince,
                        'total_bytes'      => $bytesReceived + $bytesSent,
                        'formatted_bytes'  => self::formatBytes($bytesReceived + $bytesSent),
                    ];
                }
            }
        }

        return $sessions;
    }

    private static function formatBytes(int $bytes): string
    {
        if ($bytes >= 1073741824) return number_format($bytes / 1073741824, 2) . ' GB';
        if ($bytes >= 1048576)    return number_format($bytes / 1048576, 2) . ' MB';
        if ($bytes >= 1024)       return number_format($bytes / 1024, 2) . ' KB';
        return (string)$bytes . ' B';
    }

    /**
     * Quick connectivity diagnostics via SSH.
     */
    public static function testOpenVpnConnectivity(VpnServer $server): array
    {
        $inst = new static();
        $out = [
            'server_reachable'       => false,
            'openvpn_running'        => false,
            'port_open'              => false,
            'certificates_available' => false,
            'details'                => [],
        ];

        try {
            $ssh = $inst->executeRemoteCommand($server->ip_address, 'echo ok');
            $out['server_reachable'] = ($ssh['status'] === 0);
            $out['details']['ssh'] = $ssh;

            if ($out['server_reachable']) {
                $svc  = $inst->executeRemoteCommand($server->ip_address, 'systemctl is-active openvpn@server');
                $port = $inst->executeRemoteCommand($server->ip_address, 'ss -ulnp | grep ":1194" || netstat -ulnp | grep ":1194"');
                $crt  = $inst->executeRemoteCommand($server->ip_address, 'test -s /etc/openvpn/ca.crt -a -s /etc/openvpn/ta.key && echo ok || echo missing');

                $out['openvpn_running']        = ($svc['status'] === 0 && in_array('active', $svc['output']));
                $out['port_open']              = ($port['status'] === 0 && !empty($port['output']));
                $out['certificates_available'] = ($crt['status'] === 0 && in_array('ok', $crt['output']));
                $out['details'] += compact('svc','port','crt');
            }

            Log::info("✅ Connectivity test complete for {$server->name}");
        } catch (Exception $e) {
            Log::error("❌ Connectivity test failed for {$server->name}: {$e->getMessage()}");
            $out['details']['error'] = $e->getMessage();
        }

        return $out;
    }
}